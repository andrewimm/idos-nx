//! Physical memory management.
//! It's reasonable to assume that every PC has some RAM installed. This module
//! keeps track of which physical addresses are actually backed by RAM, and
//! which frames of memory are currently in use. It also does ref-count tracking
//! for frames that might be in use by multiple tasks, so that frames are only
//! released for re-use when they are safely no longer needed.
//!
//! There are three main memory management structures:
//! 1. Frame Allocator: A bitmap data structure, allocated at system boot time,
//!    which tracks which frames of physical memory are in use. This is the
//!    source of truth for which memory is free to use. If a frame is not
//!    properly freed after use, it will be leaked and unavailable for future
//!    allocations.
//!    Also important to understand is that the frame bitmap does not track
//!    direct memmap requests. If a task requests to directly access a piece of
//!    physical memory, the bitmap will not be updated.
//! 2. Allocated Frame Tracker: A special radix tree structure which tracks
//!    reference counts for allocated frames. When a frame is allocated as part
//!    of an anonymous memmap, its ref count is initialized. When any task
//!    directly maps to a physical frame, the ref count is checked. If it
//!    exists, that means at some point the memory was allocated from the frame
//!    bitmap, and we should increment the ref count. If there is no reference
//!    in the lookup table, we assume the frame is being used for direct
//!    physical access, and we trust the caller to handle it safely. This
//!    avoids issues where a task accesses a memory-mapped peripheral, and then
//!    the space is later allocated for general use, breaking the system.
//!    When a frame is freed, the ref count is decremented. Only when it reaches
//!    zero is the frame actually released back to the frame bitmap for reuse.
//! 3. Driver Mapping Table: A table which tracks which physical frames are
//!    currently mapped to files on filesystem drivers. This is used to enable
//!    re-use of frames for read-only data, so that tasks don't need to allocate
//!    their own copies. This is particularly useful for shared libraries.

pub mod allocated_frame;
pub mod bios;
pub mod bitmap;
pub mod range;
pub mod tracking;

use core::ops::BitAnd;

use crate::memory::physical::bios::BIOS_MEMORY_MAP_LOCATION;

use super::address::PhysicalAddress;
use allocated_frame::AllocatedFrame;
use bios::load_memory_map;
use bitmap::{BitmapError, FrameBitmap};
use range::FrameRange;
use spin::Mutex;

/// Global allocator is wrapped in a mutex. It's almost never read without
/// writing, so a RwLock is unnecessary. Also, we want all operations to be
/// atomic, so we use a single lock instead of fancy atomic operations on the
/// underlying bitmap.
static ALLOCATOR: Mutex<FrameBitmap> = Mutex::new(FrameBitmap::empty());

/// Global frame reference tracker, wrapped in a mutex for safe access.
static FRAME_REF_TRACKER: Mutex<tracking::AddressTree> = Mutex::new(tracking::AddressTree::new());

/// As much as possible, try to avoid magic numbers. This is the size in bytes
/// of a single frame (4 KiB).
pub const FRAME_SIZE: u32 = 0x1000;

/// Initialize the global frame allocator at the given physical address.
/// This needs to be called before the kernel starts using any memory.
/// `location` is the physical address where the frame bitmap will be stored.
/// The length of the bitmap will only be known after reading the BIOS memory
/// map.
/// `memory_map_address` is the physical address where the BIOS memory map has
/// been stored. This was generated by the bootloader before jumping into the
/// kernel.
/// `kernel_range` is a range representing the physical addresses that currently
/// contain the kernel. When the bitmap is initialized, these are marked off so
/// that they are not re-used by other programs.
pub fn init_allocator(
    location: PhysicalAddress,
    memory_map_address: PhysicalAddress,
    kernel_range: FrameRange,
) {
    // Get the memory map from BIOS to know how much memory is installed
    let memory_map = load_memory_map(memory_map_address);
    let mut memory_end = 0;
    // The memory map from BIOS is not guaranteed to be in order
    crate::kprint!("System Memory Map:\n");
    for entry in memory_map.iter() {
        let start = entry.base as usize;
        let end = start + (entry.length as usize);
        if end > memory_end {
            memory_end = end;
        }
        crate::kprint!("{:?}\n", entry);
    }

    let mut bitmap = FrameBitmap::at_location(location, memory_end >> 12);
    bitmap.initialize_from_memory_map(memory_map).unwrap();

    // Mark the frame bitmap itself as allocated, so that it won't be reused
    let size_in_frames = bitmap.size_in_frames() as u32;
    let own_range = FrameRange::new(location, size_in_frames as u32 * FRAME_SIZE);
    bitmap.allocate_range(own_range).unwrap();
    // Mark the kernel segments as allocated
    bitmap.allocate_range(kernel_range).unwrap();
    // Mark the first 0x1000 bytes as occupied, too. We may need the BIOS data
    bitmap
        .allocate_range(FrameRange::new(PhysicalAddress::new(0), 0x1000))
        .unwrap();
    // Mark the BIOS memory map as occupied. We need to reserve this frame until
    // it's consumed by the first page directory
    bitmap
        .allocate_range(FrameRange::new(BIOS_MEMORY_MAP_LOCATION, 0x1000))
        .unwrap();

    crate::kprint!(
        "Total Memory: {} KiB\nFree Memory: {} KiB\n",
        bitmap.total_frame_count() * 4,
        bitmap.get_free_frame_count() * 4,
    );

    *ALLOCATOR.lock() = bitmap;
}

/// Helper function to access the global allocator with a closure.
pub fn with_allocator<F, T>(f: F) -> T
where
    F: Fn(&mut FrameBitmap) -> T,
{
    let mut alloc = ALLOCATOR.lock();
    f(&mut alloc)
}

/// Allocate a single frame of physical memory. Returns an `AllocatedFrame`,
/// which must be consumed and used.
/// You probably don't want to use this method, unless you are allocating kernel
/// memory that will never be shared. To make sure memory is safely tracked and
/// freed when no longer in use, use `allocate_frame_with_tracking` instead.
pub fn allocate_frame() -> Result<AllocatedFrame, BitmapError> {
    let frame_address = with_allocator(|alloc| {
        alloc
            .allocate_frames(1)
            .map(|range| range.get_starting_address())
    });
    frame_address.map(|addr| AllocatedFrame::new(addr))
}

/// Allocates memory for a single frame, and creates an entry in the refcount
/// tracker. This should be used for any memory that will be shared between
/// tasks, or mapped directly by tasks.
pub fn allocate_frame_with_tracking() -> Result<AllocatedFrame, BitmapError> {
    let allocated_frame = allocate_frame()?;
    let phys_addr = allocated_frame.peek_address();
    {
        let mut tracker = FRAME_REF_TRACKER.lock();
        tracker.add_reference(phys_addr);
    }
    Ok(allocated_frame)
}

pub fn maybe_add_frame_reference(paddr: PhysicalAddress) {
    let mut tracker = FRAME_REF_TRACKER.lock();
    let _ = tracker.add_reference_if_exists(paddr);
}

/// Get the current reference count of a tracked physical frame of memory.
/// Should probably only be used for debugging purposes!
pub fn tracked_frame_reference_count(paddr: PhysicalAddress) -> Option<usize> {
    let tracker = FRAME_REF_TRACKER.lock();
    tracker.get_reference_count(paddr)
}

/// Release a tracked frame of physical memory. This will decrement the refcount
/// for the frame, and only actually free it back to the allocator if the
/// refcount reaches zero.
/// If the frame was not allocated with tracking, this will simply free it.
/// Returns `Ok(true)` if the frame was actually freed, and `Ok(false)` if it is
/// still being tracked or was not tracked at all. Returns an error if there was
/// an issue freeing the frame.
pub fn release_tracked_frame(frame: AllocatedFrame) -> Result<bool, BitmapError> {
    let phys_addr = frame.to_physical_address();
    let remaining_ref_count = FRAME_REF_TRACKER.lock().remove_reference(phys_addr);
    if let Some(ref_count) = remaining_ref_count {
        super::LOGGER.log(format_args!(
            "Release tracked frame {:?}, remaining ref count: {}",
            phys_addr, ref_count
        ));
        if ref_count == 0 {
            super::LOGGER.log(format_args!(
                "Freeing frame {:?} from tracked release",
                phys_addr
            ));
            with_allocator(|alloc| alloc.free_frame(phys_addr))?;
            return Ok(true);
        }
    }
    Ok(false)
}

/// Allocates a contiguous range of frames of physical memory. Returns an
/// `AllocatedFrame` representing the starting address of the allocated range.
pub fn allocate_frames(count: usize) -> Result<AllocatedFrame, BitmapError> {
    let first_frame_address = with_allocator(|alloc| {
        alloc
            .allocate_frames(count)
            .map(|range| range.get_starting_address())
    });
    first_frame_address.map(|addr| AllocatedFrame::new(addr))
}

/// DANGEROUSLY release a single frame of physical memory back to the allocator.
/// You should almost never use this method directly. Instead, use
/// `release_tracked_frame`, which will safely handle reference counting.
pub fn release_frame(address: PhysicalAddress) -> Result<(), BitmapError> {
    let range = FrameRange::new(address, FRAME_SIZE);
    with_allocator(|alloc| alloc.free_range(range))
}

/// Get the total length of the frame bitmap, in bytes. This is used to know how
/// much physical memory is occupied by the bitmap itself.
pub fn get_allocator_size() -> usize {
    with_allocator(|alloc| alloc.size_in_bytes())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test_case]
    fn allocate_and_release_frame() {
        let frame = allocate_frame().expect("Failed to allocate frame");
        let addr = frame.to_physical_address();
        release_frame(addr).expect("Failed to release frame");
        with_allocator(|alloc| {
            assert!(!alloc.is_address_allocated(addr));
        });
    }

    #[test_case]
    fn allocate_and_release_tracked_frame() {
        let frame = allocate_frame_with_tracking().expect("Failed to allocate tracked frame");
        let addr = frame.peek_address();
        release_tracked_frame(frame).expect("Failed to release tracked frame");
        with_allocator(|alloc| {
            assert!(!alloc.is_address_allocated(addr));
        });
    }

    #[test_case]
    fn tracked_frame_reference_counting() {
        let frame = allocate_frame_with_tracking().expect("Failed to allocate tracked frame");
        let addr = frame.peek_address();
        // Add another reference manually
        {
            let mut tracker = FRAME_REF_TRACKER.lock();
            assert_eq!(tracker.add_reference_if_exists(addr), Some(2));
            assert_eq!(tracker.add_reference_if_exists(addr), Some(3));
        }
        release_tracked_frame(frame).expect("Failed to release tracked frame");
        with_allocator(|alloc| {
            assert!(alloc.is_address_allocated(addr));
        });
        // if we were unmapping memory, it would construct the AllocatedFrame
        // object for us
        release_tracked_frame(AllocatedFrame::new(addr)).expect("Failed to release tracked frame");
        with_allocator(|alloc| {
            assert!(alloc.is_address_allocated(addr));
        });
        // on the third release, it'll no longer be tracked and should be freed
        // by the allocator
        release_tracked_frame(AllocatedFrame::new(addr)).expect("Failed to release tracked frame");
        with_allocator(|alloc| {
            assert!(!alloc.is_address_allocated(addr));
        });
    }
}
