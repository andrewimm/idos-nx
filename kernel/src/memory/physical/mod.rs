//! Physical memory management.
//! It's reasonable to assume that every PC has some RAM installed. This module
//! keeps track of which physical addresses are actually backed by RAM, and
//! which frames of memory are currently in use. It also does ref-count tracking
//! for frames that might be in use by multiple tasks, so that frames are only
//! released for re-use when they are safely no longer needed.
//!
//! There are three main memory management structures:
//! 1. Frame Allocator: A bitmap data structure, allocated at system boot time,
//!    which tracks which frames of physical memory are in use. This is the
//!    source of truth for which memory is free to use. If a frame is not
//!    properly freed after use, it will be leaked and unavailable for future
//!    allocations.
//!    Also important to understand is that the frame bitmap does not track
//!    direct memmap requests. If a task requests to directly access a piece of
//!    physical memory, the bitmap will not be updated.
//! 2. Allocated Frame Tracker: A special radix tree structure which tracks
//!    reference counts for allocated frames. When a frame is allocated as part
//!    of an anonymous memmap, its ref count is initialized. When any task
//!    directly maps to a physical frame, the ref count is checked. If it
//!    exists, that means at some point the memory was allocated from the frame
//!    bitmap, and we should increment the ref count. If there is no reference
//!    in the lookup table, we assume the frame is being used for direct
//!    physical access, and we trust the caller to handle it safely. This
//!    avoids issues where a task accesses a memory-mapped peripheral, and then
//!    the space is later allocated for general use, breaking the system.
//!    When a frame is freed, the ref count is decremented. Only when it reaches
//!    zero is the frame actually released back to the frame bitmap for reuse.
//! 3. Driver Mapping Table: A table which tracks which physical frames are
//!    currently mapped to files on filesystem drivers. This is used to enable
//!    re-use of frames for read-only data, so that tasks don't need to allocate
//!    their own copies. This is particularly useful for shared libraries.

pub mod allocated_frame;
pub mod bios;
pub mod bitmap;
pub mod range;

use crate::memory::physical::bios::BIOS_MEMORY_MAP_LOCATION;

use super::address::PhysicalAddress;
use allocated_frame::AllocatedFrame;
use bios::load_memory_map;
use bitmap::{BitmapError, FrameBitmap};
use range::FrameRange;
use spin::Mutex;

/// Global allocator is wrapped in a mutex. It's almost never read without
/// writing, so a RwLock is unnecessary. Also, we want all operations to be
/// atomic, so we use a single lock instead of fancy atomic operations on the
/// underlying bitmap.
static ALLOCATOR: Mutex<FrameBitmap> = Mutex::new(FrameBitmap::empty());

/// As much as possible, try to avoid magic numbers. This is the size in bytes
/// of a single frame (4 KiB).
pub const FRAME_SIZE: u32 = 0x1000;

/// Initialize the global frame allocator at the given physical address.
/// This needs to be called before the kernel starts using any memory.
/// `location` is the physical address where the frame bitmap will be stored.
/// The length of the bitmap will only be known after reading the BIOS memory
/// map.
/// `memory_map_address` is the physical address where the BIOS memory map has
/// been stored. This was generated by the bootloader before jumping into the
/// kernel.
/// `kernel_range` is a range representing the physical addresses that currently
/// contain the kernel. When the bitmap is initialized, these are marked off so
/// that they are not re-used by other programs.
pub fn init_allocator(
    location: PhysicalAddress,
    memory_map_address: PhysicalAddress,
    kernel_range: FrameRange,
) {
    // Get the memory map from BIOS to know how much memory is installed
    let memory_map = load_memory_map(memory_map_address);
    let mut memory_end = 0;
    // The memory map from BIOS is not guaranteed to be in order
    crate::kprint!("System Memory Map:\n");
    for entry in memory_map.iter() {
        let start = entry.base as usize;
        let end = start + (entry.length as usize);
        if end > memory_end {
            memory_end = end;
        }
        crate::kprint!("{:?}\n", entry);
    }

    let mut bitmap = FrameBitmap::at_location(location, memory_end >> 12);
    bitmap.initialize_from_memory_map(memory_map).unwrap();

    // Mark the frame bitmap itself as allocated, so that it won't be reused
    let size_in_frames = bitmap.size_in_frames() as u32;
    let own_range = FrameRange::new(location, size_in_frames as u32 * FRAME_SIZE);
    bitmap.allocate_range(own_range).unwrap();
    // Mark the kernel segments as allocated
    bitmap.allocate_range(kernel_range).unwrap();
    // Mark the first 0x1000 bytes as occupied, too. We may need the BIOS data
    bitmap
        .allocate_range(FrameRange::new(PhysicalAddress::new(0), 0x1000))
        .unwrap();
    // Mark the BIOS memory map as occupied. We need to reserve this frame until
    // it's consumed by the first page directory
    bitmap
        .allocate_range(FrameRange::new(BIOS_MEMORY_MAP_LOCATION, 0x1000))
        .unwrap();

    crate::kprint!(
        "Total Memory: {} KiB\nFree Memory: {} KiB\n",
        bitmap.total_frame_count() * 4,
        bitmap.get_free_frame_count() * 4,
    );

    *ALLOCATOR.lock() = bitmap;
}

/// Helper function to access the global allocator with a closure.
pub fn with_allocator<F, T>(f: F) -> T
where
    F: Fn(&mut FrameBitmap) -> T,
{
    let mut alloc = ALLOCATOR.lock();
    f(&mut alloc)
}

/// Allocate a single frame of physical memory. Returns an `AllocatedFrame`,
/// which must be consumed and used.
pub fn allocate_frame() -> Result<AllocatedFrame, BitmapError> {
    let frame_address = with_allocator(|alloc| {
        alloc
            .allocate_frames(1)
            .map(|range| range.get_starting_address())
    });
    frame_address.map(|addr| AllocatedFrame::new(addr))
}

/// Allocates a contiguous range of frames of physical memory. Returns an
/// `AllocatedFrame` representing the starting address of the allocated range.
pub fn allocate_frames(count: usize) -> Result<AllocatedFrame, BitmapError> {
    let first_frame_address = with_allocator(|alloc| {
        alloc
            .allocate_frames(count)
            .map(|range| range.get_starting_address())
    });
    first_frame_address.map(|addr| AllocatedFrame::new(addr))
}

/// Release a single frame of physical memory back to the allocator.
pub fn release_frame(address: PhysicalAddress) -> Result<(), BitmapError> {
    let range = FrameRange::new(address, FRAME_SIZE);
    with_allocator(|alloc| alloc.free_range(range))
}

/// Get the total length of the frame bitmap, in bytes. This is used to know how
/// much physical memory is occupied by the bitmap itself.
pub fn get_allocator_size() -> usize {
    with_allocator(|alloc| alloc.size_in_bytes())
}
