use super::super::address::PhysicalAddress;

pub const REGION_TYPE_FREE: u32 = 1;
pub const REGION_TYPE_RESERVED: u32 = 2;
pub const REGION_TYPE_ACPI_RECOVERABLE: u32 = 3;
pub const REGION_TYPE_ACPI_NVS: u32 = 4;
pub const REGION_TYPE_BAD: u32 = 5;

/// Structure for handling the data generated by the BIOS memory mapping call
/// (INT 0x15, EAX = 0xE820). The method generates a map somewhere in memory
/// where each 24-bit entry identifies a region of memory.
#[repr(C, packed)]
pub struct MapEntry {
    pub base: u64,
    pub length: u64,
    pub region_type: u32,
    pub acpi: u32,
}

impl core::fmt::Debug for MapEntry {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let type_string = match self.region_type {
            REGION_TYPE_FREE => "Free",
            REGION_TYPE_RESERVED => "Reserved",
            REGION_TYPE_ACPI_RECOVERABLE => "ACPI Recoverable",
            REGION_TYPE_ACPI_NVS => "ACPU NVS",
            REGION_TYPE_BAD => "Bad",
            _ => "Unknown",
        };
        let start = self.base;
        let end = self.base + self.length - 1;
        write!(f, "{:#010X}-{:#010X}: {}", start, end, type_string)
    }
}

pub fn load_memory_map(addr: PhysicalAddress) -> &'static [MapEntry] {
    let length_addr: u32 = addr.into();
    let length_ptr = length_addr as *mut u32;
    unsafe {
        let first_entry = length_ptr.offset(1) as *mut MapEntry;
        core::slice::from_raw_parts_mut(first_entry, *length_ptr as usize)
    }
}
